Randomise: 
Spacing
Size/shape (occasional long thin one)
Tears/holes
Weight/stiffness. 


For each flag:

1. Pick random plane (Size, shape + tears)
2. Duplicate
3. Assign correct colour material
4. Move to position
5. Randomise Contrained Vertices
6. move locator to next position with slight random distance variance  


-------------------------------------------------------------------------------------------------------------------

Test 01: Plane placement on a curve.


//set these////
int $flagNumber = 100;
//set these////


//Declared variables////
string $flagsArray[5] = {"pPlane1", "pPlane2", "pPlane3", "pPlane4", "pPlane5"};
int $random;
int $flagNumberCounter = 1;
int $flagPositionCounter;
int $flagColourCounter = 0;
vector $moveVector = <<0, 0, 0>>;
//Declared variables////

select -r curve1;
duplicate;
move -rpr 0 0 0;

while (($flagNumberCounter) <= ($flagNumber)){
    
    select $flagsArray[$flagColourCounter];
    duplicate;
    move -rpr ($moveVector.x) ($moveVector.y) ($moveVector.z);  
    $flagNumberCounter = (($flagNumberCounter) + 1);
    $moveVector = <<($moveVector.x), ($moveVector.y), ($moveVector.z - 2)>>;
    $flagColourCounter = (($flagColourCounter) + 1);
    
    if (($flagColourCounter) == 5){
        $flagColourCounter = 0;
    } 
    
    
}



-------------------------------------------------------------------------------------------------------------------

Test 02: Matrix Flag Placement


//set these////
int $flagNumber = 10;
//set these////


//Declared variables////
string $flagArray[25] = {"pPlane1","pPlane2","pPlane3","pPlane4","pPlane5","pPlane6","pPlane7","pPlane8","pPlane9","pPlane10","pPlane11","pPlane12","pPlane13","pPlane14","pPlane15","pPlane16","pPlane17","pPlane18","pPlane19","pPlane20","pPlane21","pPlane22","pPlane23","pPlane24","pPlane25"};
matrix $flagMatrix[5] [5] = <<0,1,2,3,4 ; 5,6,7,8,9 ; 10,11,12,13,14 ; 15,16,17,18,19 ; 20,21,22,23,24>>;

int $random;
int $flagNumberCounter = 1;
int $flagPositionCounter;
int $flagColourCounter = 0;
int $arrayStringPicker;
vector $moveVector = <<0, 0, 0>>;
//Declared variables////

select -r curve1;
duplicate;
move -rpr 0 0 0;

while (($flagNumberCounter) <= ($flagNumber)){
    
    $random = rand(0,4);
    $arrayStringPicker = $flagMatrix[$flagColourCounter][$random];
    select $flagArray[$arrayStringPicker];
    duplicate;
    move -rpr ($moveVector.x) ($moveVector.y) ($moveVector.z);  
    $flagNumberCounter = (($flagNumberCounter) + 1);
    $moveVector = <<($moveVector.x), ($moveVector.y), ($moveVector.z - 2)>>;
    $flagColourCounter = (($flagColourCounter) + 1);
    
    if (($flagColourCounter) == 5){
        $flagColourCounter = 0;
    } 
    
    
}

-------------------------------------------------------------------------------------------------------------------

Test 03: Texture + nCloth

//set these////
int $flagNumber = 50;
//set these////


int $flagColourCounter = 0;
int $flagNumberCounter = 0;
int $randomInt;
float $randomFloat;
vector $moveFlagVector = <<0, 0, 0>>;
string $currentSelection[]; 

string $flagColourArray[5] = {"blueFlagMat", "whiteFlagMat", "redFlagMat", "greenFlagMat", "yellowFlagMat"};
string $flagPlaneArray[6] = {"pPlane1", "pPlane2", "pPlane3", "pPlane4", "pPlane5", "pPlane6"};


//Main Loop.
while (($flagNumberCounter) < ($flagNumber)){

    $randomInt = rand(0,6); //set
    select $flagPlaneArray[$randomInt];    
    duplicate;
    $currentSelection = `ls -sl`; 
    hyperShade -assign $flagColourArray[$flagColourCounter];
    move -rpr ($moveFlagVector.x) ($moveFlagVector.y) ($moveFlagVector.z);
    createNCloth 0; 
    select $currentSelection[0];  
    select `ls -sl` .vtx[110];
    select `ls -sl` .vtx[120];
    createNConstraint transform 0;
    $randomFloat = rand(1.5, 2);//optomise with better float values
    $moveFlagVector = <<($moveFlagVector.x + $randomFloat), ($moveFlagVector.y), ($moveFlagVector.z)>>;
	$flagNumberCounter++;
	$flagColourCounter++;
	
	if (($flagColourCounter) == 5){
	    $flagColourCounter = 0;
	}	
}
//Main Loop.



-------------------------------------------------------------------------------------------------------------------

Test 04: Single nCloth for all Meshes


//set these////
int $flagNumber = 10;
//set these////


int $flagColourCounter = 0;
int $flagNumberCounter = 0;
int $randomInt;
float $randomFloat;
vector $moveFlagVector = <<0, 0, 0>>;
string $currentSelection[];
string $currentSelectionArray[]; 

string $flagColourArray[5] = {"blueFlagMat", "whiteFlagMat", "redFlagMat", "greenFlagMat", "yellowFlagMat"};
string $flagPlaneArray[6] = {"pPlane1", "pPlane2", "pPlane3", "pPlane4", "pPlane5", "pPlane6"};


//Main Loop.
while (($flagNumberCounter) < ($flagNumber)){

    if($flagNumberCounter == 0){    
        $randomInt = rand(0,6); //set to size of plane array.
        select $flagPlaneArray[$randomInt];    
        duplicate;
        $currentSelection = `ls -sl`; 
        move -rpr ($moveFlagVector.x) ($moveFlagVector.y) ($moveFlagVector.z);
        $randomFloat = rand(1.5, 2);//optomise with better float values
        $moveFlagVector = <<($moveFlagVector.x + $randomFloat), ($moveFlagVector.y), ($moveFlagVector.z)>>;
    	$flagNumberCounter++;
	}
	
	else{
	    $randomInt = rand(0,6); //set to size of plane array.
        select $flagPlaneArray[$randomInt];    
        duplicate;
        move -rpr ($moveFlagVector.x) ($moveFlagVector.y) ($moveFlagVector.z);
        select -add $currentSelection;
        $currentSelection = `ls -sl`;
        select -r $currentSelection[1];
        select -add $currentSelection[0];
        polyUnite;
        $currentSelection = `ls -sl`;
        $randomFloat = rand(1.5, 2);//optomise with better float values
        $moveFlagVector = <<($moveFlagVector.x + $randomFloat), ($moveFlagVector.y), ($moveFlagVector.z)>>;
    	$flagNumberCounter++;	    
	}
	
	
	
	if($flagNumberCounter == $flagNumber){
        createNCloth 0;
        $flagNumberCounter = 0;
        
        while($flagNumberCounter < $flagNumber){
            select $currentSelection;
            select -tgl `ls -sl` .f[$flagNumberCounter * 100 : $flagNumberCounter * 100 + 99];
            hyperShade -assign $flagColourArray[$flagColourCounter];
            select $currentSelection;
            select `ls -sl` .vtx[11 * (11 * ($flagNumberCounter + 1) - 1)];
            select `ls -sl` .vtx[121 * ($flagNumberCounter + 1) - 1];
            createNConstraint transform 0;
            $flagColourCounter++;
            $flagNumberCounter++;
            
            if ($flagColourCounter == 5){
	            $flagColourCounter = 0;
            }
        } 	    	    
	}
	
	
		
}
//Main Loop.


-------------------------------------------------------------------------------------------------------------------




Test 05: nHair rope and dynamic

//set these////
int $flagNumber = 10;
//set these////


int $flagColourCounter = 0;
int $flagNumberCounter = 0;
int $randomInt;
float $randomFloat;
vector $moveFlagVector = <<0, 0, 0>>;
vector $moveCircleVector = <<0, 0, 0>>;
string $currentSelection[];
string $currentSelectionArray[]; //Is this needed?
string $currentCurveSelection[];
string $currentNodeSelection[];
string $currentExtrudedSelection[];

string $flagColourArray[5] = {"blueFlagMat", "whiteFlagMat", "redFlagMat", "greenFlagMat", "yellowFlagMat"};
string $flagPlaneArray[6] = {"pPlane1", "pPlane2", "pPlane3", "pPlane4", "pPlane5", "pPlane6"};


//Main Loop.
while (($flagNumberCounter) < ($flagNumber)){

    if($flagNumberCounter == 0){    
        $randomInt = rand(0,6); //set to size of plane array.
        select $flagPlaneArray[$randomInt];    
        duplicate;
        $currentSelection = `ls -sl`; 
        move -rpr ($moveFlagVector.x) ($moveFlagVector.y) ($moveFlagVector.z);
        $randomFloat = rand(1.5, 2);//optomise with better float values
        $moveFlagVector = <<($moveFlagVector.x + $randomFloat), ($moveFlagVector.y), ($moveFlagVector.z)>>;
    	$flagNumberCounter++;
	}
	
	else{
	    $randomInt = rand(0,6); //set to size of plane array.
        select $flagPlaneArray[$randomInt];    
        duplicate;
        move -rpr ($moveFlagVector.x) ($moveFlagVector.y) ($moveFlagVector.z);
        select -add $currentSelection;
        $currentSelection = `ls -sl`;
        select -r $currentSelection[1];
        select -add $currentSelection[0];
        polyUnite;
        $currentSelection = `ls -sl`;
        $randomFloat = rand(1.5, 2);//optomise with better float values
        $moveFlagVector = <<($moveFlagVector.x + $randomFloat), ($moveFlagVector.y), ($moveFlagVector.z)>>;
    	$flagNumberCounter++;	    
	}
	
	
	
	if($flagNumberCounter == $flagNumber){
	    
	    
	    
	    //nHair rope
	    curve -d 2 -p -5 0 0 -p 6 0 0 -p 25 0 0;//change -p to locators.
	    $currentCurveSelection = `ls -sl`;
	    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 200 -d 3 -tol 0.01;// change -s (spans)!
	    select $currentCurveSelection;
	    makeCurvesDynamic 2 { "1", "0", "1", "1", "0"};
	    hide $currentCurveSelection;
	    $currentCurveSelection = `ls -sl`;
	    $currentNodeSelection = `listConnections -d 1 -sh 1 -t shape`;
	    select $currentNodeSelection[0];
	    $currentNodeSelection = `listConnections -t shape`;
	    setAttr ($currentCurveSelection[0] + ".stretchResistance") 1500;
	    circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 0.02 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;//refine -r radius .02?
	    rotate -r -os 0 0 -90;
	    move -rpr -x -5;//change to locators
	    select -tgl $currentNodeSelection[3];
	    extrude -ch true -rn false -po 1 -et 2 -ucp 1 -fpt 1 -upn 1 -rotation 0 -scale 1 -rsp 1;
	    $currentExtrudedSelection = `ls -sl`;
	    setAttr ($currentCurveSelection[0] + ".selfCollide") 1;
	    setAttr ($currentCurveSelection[0] + ".collideWidthOffset") 0.018;   
	    //nHair rope	  
	    
	    
	    //nCloth flags + assign shaders
	    select $currentSelection;
        createNCloth 0;
        $flagNumberCounter = 0;
        
        while($flagNumberCounter < $flagNumber){
            select $currentSelection;
            select -tgl `ls -sl` .f[$flagNumberCounter * 100 : $flagNumberCounter * 100 + 99];
            hyperShade -assign $flagColourArray[$flagColourCounter];
            select $currentSelection;
            select `ls -sl` .vtx[11 * (11 * ($flagNumberCounter + 1) - 1)];
            select `ls -sl` .vtx[121 * ($flagNumberCounter + 1) - 1];
            select -tgl $currentSelection;
            select -tgl $currentExtrudedSelection; //make dynamic
            //print(`ls -sl`);
            createNConstraint pointToSurface 0;
            $flagColourCounter++;
            $flagNumberCounter++;
            
            if ($flagColourCounter == 5){
	            $flagColourCounter = 0;
            }
        }
        //nCloth flags + assign shaders 	    	    
	}
	
	
		
}
//Main Loop.



-------------------------------------------------------------------------------------------------------------------

Test 06: Locators + eular rotation


//Locator Creator////
spaceLocator -p 0 0 0 -name "locatorStart";
setAttr "locatorStart.overrideEnabled" 1;
setAttr "locatorStart.overrideColor" 13;
spaceLocator -p 0 0 0 -name "locatorEnd";
setAttr "locatorEnd.overrideEnabled" 1;
setAttr "locatorEnd.overrideColor" 9;
move -rpr 10 0 0;
//Locator Creator////



//Declared variables
int $flagColourCounter = 0;
int $flagNumberCounter = 0;
int $randomInt;
int $flagsCreatedNumber = 0;
float $randomFloat;
float $countX;
float $countY;
float $countZ;
float $flagRopeLength;
float $vertexFloat;
float $vertexArray[];
vector $rotEuler;
vector $midPoint;
vector $moveFlagVector = <<3, 0, 0>>;
vector $locatorStartVector = <<0, 0, 0>>;
vector $locatorEndVector = <<0, 0, 0>>;
string $flagsCreatedString[];
string $currentSelection[];
string $currentSelection2[];
string $currentCurveSelection[];
string $currentNodeSelection[];
string $currentExtrudedSelection[];
string $flagsCreatedArray[];
string $flagColourArray[5] = {"blueFlagMat", "whiteFlagMat", "redFlagMat", "greenFlagMat", "yellowFlagMat"};
string $flagPlaneArray[] = {"flagMesh1", "flagMesh2", "flagMesh3", "flagMesh4", "flagMesh5", "flagMesh6", "flagMesh7", "flagMesh8", "flagMesh9"};
int $flagPicked[];
//Declared variables


//Number Set Generator. 
int $intArray[50];
int $intArrayCounter = 0;
int $intWrite = 0;

while ($intArrayCounter < 30){
    
    if ($intArrayCounter < 22){
        $intArray[$intArrayCounter] = $intWrite;//1 repeated 43 times. 
        print($intArray[$intArrayCounter] + "\n");
    }
    
    else {
        $intArray[$intArrayCounter] = $intWrite + 1;//Business as usual.
        $intWrite++; 
        print($intArray[$intArrayCounter] + "\n");
    }    
    $intArrayCounter++;
}
//Number Set Generator.



//Main Loop.

//Get x,y,z coordinates for Locators 
select locatorStart;
vector $locatorStartVector = `xform -q -t -ws`;
select locatorEnd;
vector $locatorEndVector = `xform -q -t -ws`;
//Get x,y,z coordinates for Locators

//Mid point
$countX = ($locatorStartVector.x + $locatorEndVector.x) / 2 ;
$countY = ($locatorStartVector.y + $locatorEndVector.y) / 2 ;
$countZ = ($locatorStartVector.z + $locatorEndVector.z) / 2 ;
$midPoint = << ($countX), ($countY), ($countZ)  >>;
//spaceLocator -p ($midPoint.x) ($midPoint.y) ($midPoint.z) -name "middleTest";
//Mid Point

//Vector magnitude (distance between locators)
$countX = ($locatorEndVector.x - $locatorStartVector.x);
$countY = ($locatorEndVector.y - $locatorStartVector.y);
$countZ = ($locatorEndVector.z - $locatorStartVector.z);
$flagRopeLength = (sqrt(($countX * $countX) + ($countY * $countY) + ($countZ * $countZ)));
//Distance between locators (distance between locators)

//Required Vector Euler Rotation
vector $vectorMaster = << ($countX), ($countY), ($countZ) >>; 
vector $vectorSlave = << (1), (0), (0) >>;
$rotEuler = `angleBetween -euler -v1 ($vectorSlave.x) ($vectorSlave.y) ($vectorSlave.z) -v2 ($vectorMaster.x) ($vectorMaster.y) ($vectorMaster.z)`;
print($rotEuler);
//Required Vector Euler Rotation




while (($moveFlagVector.x) <= ($flagRopeLength - 3)){

    if($flagNumberCounter == 0){    
        $randomInt = rand(0,50); 
        select $flagPlaneArray[$intArray[$randomInt]];    
        duplicate;
        $currentSelection = `ls -sl`; 
        move -rpr ($moveFlagVector.x) ($moveFlagVector.y) ($moveFlagVector.z);
        $randomFloat = rand(0.1, 0.3);//Gap between flags
        select .vtx[121 * ($flagNumberCounter + 1) - 1];
        $vertexArray = `xform -q -t -ws`;
        $vertexFloat = $vertexArray[0];
        $moveFlagVector = <<($vertexFloat + $randomFloat), ($moveFlagVector.y), ($moveFlagVector.z)>>;
    	$flagNumberCounter++;
    	$flagsCreatedNumber++;
	}
	
	else{
	    $randomInt = rand(0,50);
        select $flagPlaneArray[$intArray[$randomInt]];    
        duplicate;
        $currentSelection2 = `ls -sl`;
        move -rpr ($moveFlagVector.x) ($moveFlagVector.y) ($moveFlagVector.z);
        select .vtx[121 * ($flagNumberCounter + 1) - 1];
        $vertexArray = `xform -q -t -ws`;
        $vertexFloat = $vertexArray[0];
        select $currentSelection2;       
        select -add $currentSelection;
        $currentSelection = `ls -sl`;
        select -r $currentSelection[1];
        select -add $currentSelection[0];
        polyUnite;
        $currentSelection = `ls -sl`;
        $randomFloat = rand(0.1, 0.3);//Gap between flags
        $moveFlagVector = <<($vertexFloat + $randomFloat), ($moveFlagVector.y), ($moveFlagVector.z)>>;
    	$flagNumberCounter++;
    	$flagsCreatedNumber++;	    
	}
	
	
	
	if(($moveFlagVector.x) > ($flagRopeLength -3)){
	    
	    
	    
	    //nHair rope
	    curve -d 2 -p ($locatorStartVector.x) ($locatorStartVector.y) ($locatorStartVector.z) -p ($midPoint.x) ($midPoint.y) ($midPoint.z) -p ($locatorEndVector.x) ($locatorEndVector.y) ($locatorEndVector.z);
	    $currentCurveSelection = `ls -sl`;
	    rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 500 -d 3 -tol 0.01;// change -s (spans)!
	    select $currentCurveSelection;
	    makeCurvesDynamic 2 { "1", "0", "1", "1", "0"};
	    hide $currentCurveSelection;
	    $currentCurveSelection = `ls -sl`;
	    $currentNodeSelection = `listConnections -d 1 -sh 1 -t shape`;
	    select $currentNodeSelection[0];
	    $currentNodeSelection = `listConnections -t shape`;
	    setAttr ($currentCurveSelection[0] + ".stretchResistance") 1500;
	    circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 0.02 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;//refine -r radius .02?
	    //rotate -r -os ($rotEuler.x) ($rotEuler.y) ($rotEuler.z) ;//rotation doesn't work and not actually neccessary.
	    move -rpr ($locatorStartVector.x) ($locatorStartVector.y) ($locatorStartVector.z);
	    select -tgl $currentNodeSelection[3];        
	    extrude -ch true -rn false -po 1 -et 2 -ucp 1 -fpt 1 -upn 1 -rotation 0 -scale 1 -rsp 1;
	    hyperShade -assign ropeMat;
	    $currentExtrudedSelection = `ls -sl`;
	    setAttr ($currentCurveSelection[0] + ".selfCollide") 1;
	    setAttr ($currentCurveSelection[0] + ".collideWidthOffset") 0.018;   
	    //nHair rope	  
	    
	    
	    //nCloth flags
	    select $currentSelection;
	    $flagsCreatedString = `ls -sl`;
        createNCloth 0;
        //nCloth flags	    	    
	}
	
	
		
}


//Asign flag shaders and nConstrains and then move to $midPoint and apply vector euler rotation 
$flagNumberCounter = 0;

while($flagNumberCounter < $flagsCreatedNumber){
            select $currentSelection;
            select -tgl `ls -sl` .f[$flagNumberCounter * 100 : $flagNumberCounter * 100 + 99];
            hyperShade -assign $flagColourArray[$flagColourCounter];
            select $currentSelection;
            select `ls -sl` .vtx[11 * (11 * ($flagNumberCounter + 1) - 1) : 121 * ($flagNumberCounter + 1) - 1 ];
            select -tgl $currentSelection;
            select -tgl $currentExtrudedSelection;
            createNConstraint pointToSurface 0;
            $flagColourCounter++;
            $flagNumberCounter++;
            
            if ($flagColourCounter == 5){
	            $flagColourCounter = 0;
            }
}

select $flagsCreatedString;
//CenterPivot;
move -rpr ($locatorStartVector.x) ($locatorStartVector.y) ($locatorStartVector.z);
rotate -r ($rotEuler.x) ($rotEuler.y) ($rotEuler.z);
//Asign flag shaders and nConstrains and then move to $midPoint and apply vector euler rotation 
        
        
        
//Main Loop.
-------------------------------------------------------------------------------------------------------------------









